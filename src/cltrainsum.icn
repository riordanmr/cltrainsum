# This program, written in the Icon programming language, summarizes
# (exercise) training log data from a file usually known as CLTRAINEW.
#
# CLTRAINEW was created by Paul S. Wolberg in January 1985, to track
# training done by a team preparing for the MSU
# (Michigan State University) Classic team triathlon.
# Later, the file devolved into a log for training done by me,
# Mark Riordan.  
#
# Entries in the log are in chronological order.  Entries in the log
# changed format over time, until the format mostly settled down in mid-1988.
# This program recognizes only entries in this "new" format.
# Therefore, input to the program ought to be pre-processed to remove
# any lines prior to (typically) 1989-01-01.
#
# I thought of writing this program shortly after Fall 1986, when I ordered
# and received an Icon distribution tape (for VAX/VMS) from the University of Arizona.
# But I didn't start writing it until March 21, 2022.
# Mark Riordan  riordan@rocketmail.com 

# The input file contains lines with a date followed by zero or more
# workouts separated by semi-colons.  Comments may be included in parentheses,
# which may be nested.  Most days contain only one line, but multiple lines for
# a given date are possible, in which case subsequent lines start with a +
# in column 1.
# Here's an example:
#   07/23  0.6 miles sr; 18.3 miles br.; 4.6 miles rr.  (Capitol City Triathlon.
#   +      Think swim may have been short. 
# In later years, I started omitting the units, due to the difficulty of entering
# text on a mobile phone.  If units are omitted, they default to a fixed unit
# based on activity type (usually miles), like this:
#   9/09 [124.8T] 13.29 b.; 2.3 w. 
# Body weight in pounds may be present in square brackets.  If followed by T,
# the weight was measured on Tam's old scale, which is believed to read 
# 0.8 pounds low.
# Blank lines may be present, and can be ignored.  They should occur only between
# a Saturday and a Sunday.
# The first day of every year contains the sequence (*** nnnn )
# where nnnn is the year. 

link strings

global oldyear, outfile, tableActTypes

procedure ltrim(txt)
    while txt[1] == " " do {
        txt[1] := ""
    }
    return txt
end

# From http://www2.cs.arizona.edu/icon/ftp/newsgrp/group96a.txt
procedure join(stringList,separator)
  local result
  result := get(stringList)
  every result ||:= separator || !stringList
  return result
end

procedure split(string,separator)
  local result
  string ? {
    until pos(0) do {
      result := tab(find(separator) | 0)
      suspend result
      move(*separator)
    }
  }
end

# Remove comments from input.  As with PostScript, comments 
# start with ( and end with ).  Comments may be embedded in other comments.
# Returns the decommented version of the string.
# Credit: https://www2.cs.arizona.edu/~collberg/Teaching/372/2005/Html/Html-34/
procedure decomment(S);
   while (1) do {
      if f := find("(",S) &
         t := find(")",S,f+1) &
         not (find("(",S,f+1) < t) &
         not (find(")",S,f+1) < t) then 
         S[f:t+1] := ""
      else
         break
   }
   return S;
end

# Given a raw individual activity, parse and return its components.
procedure procActivity(adate,activity,iline)
    activity := ltrim(trim(activity))
    write("date: '", adate, "' activity: '", activity,"'")
    # Crack off the leading quantity.
    if activity ? { quant := tab(many('0123456789.')) & rem := tab(many(&ascii)) } then {
        #write("  quant='", quant,"' rem='", rem, "'")
    } else {
        write("!! On line ", iline, " failed to parse ", activity)
        fail
    }

    rem := ltrim(rem)
    units := ""
    activityType := ""
    if rem ? { units:= tab(many(&ascii -- ' '))} then {
        activityType := ltrim(trim(rem[1+*units:0]))
        if *activityType == 0 then {
            activityType := units
            units := ""
        }
    }
    #write(outfile,"  quant='", quant,"' units='",units,"' activityType='",activityType,"'")
    tableActTypes[activityType] +:= 1
    write(outfile,adate,",",quant,",",units,",",activityType)
end

# Proceess the data for an entire day.  The input has been partially parsed.
# 
procedure procParsedDay(adate, inbrack, activities, iline)
    every procActivity(adate,split(activities,";"), iline)
end

# Process the data for an entire day.
# Entry:    line is the raw lines for one day, except that any continuation lines
#               have been collapsed into one line.
#           iline is the line number, for debugging purposes.
procedure procRawDay(line, iline) 
    #write("proc1line line ", iline, " oldyear=", oldyear, ": ", line)
    year := oldyear

    # Look for text like:   *** 2001   and if present, extract the year from it.
    line ? { if tab(find("*** ")) then { move(4); year := 0+tab(many('0123456789')); }};
    if year ~= oldyear then {
        if oldyear ~= 0 then {
            if year ~= (oldyear+1) then {
                write("** Error: year is ", year, " prev year was ", oldyear)
            }
        }
        oldyear := year
    }
    line := decomment(line)
    line := trim(line)

    if *line > 0 then {
        lineGood := 1
        if not many(&digits,line) then {
            write("** No leading date on line ", iline, " ", line)
            lineGood := 0
        } else if line[3] == "/" then {
            line[3] := "-"
            line := year || "-" || line
            write(line)
            if *line < 10 then {
                write("** Line ", iline, " too short: ", line)
                lineGood := 0
            }            
        } else {
            write("** Missing / in date on line ", iline, " ", line)
            lineGood := 0
        }
        
        if lineGood == 1 then {
            # 1971-08-10  26.4 miles b.
            # 123456789a1

            # Strip off the leading date.
            adate := line[1:11]
            rem := ""
            if *line > 10 then {
                rem := ltrim(line[11:1+*line])
            }

            # Extract the info in [].  This will be weight data,
            # plus occasionally other information like blood pressure.
            # Note that older records had this at the end, rather than the beginning.
            inbrack := ""
            if rem ? {tab(find("[")) & move(1) & inbrack := tab(many(&ascii -- ']')) & clbr := match("]") } then {
                rem := replace(rem,"[" || inbrack || "]", "")
                #write("Matched []. inbrack='",inbrack,"' clbr=",clbr," rem='", rem, "'")
            }
            write("date='",adate,"' inbrack='",inbrack,"' rem='",rem,"'")
            procParsedDay(adate, inbrack, rem, iline)
        }
    }

end

procedure wrapup()
    #sortedList := sort(tableActTypes,4)
    every act := !sort(tableActTypes,2) do {
        write(image(act[1]),"\t", act[2])
    }
    #every write(k:=key(tableActTypes),"\t",tableActTypes[k])
end

procedure readlines()
    outfile := open("act.csv", "w")
    tableActTypes := table(0)
    entireline := &null
    oldyear := 0
    iline := 0

    while line := trim(read()) do {
        if *line > 0 then {
            if line[1] == "+" then {
                entireline := entireline || line[2:1+*line]
            } else {
                if \entireline then {
                    procRawDay(entireline, iline)
                }
                entireline := line
            }
        }
        iline := iline + 1;
    }
    # Handle last line.
    procRawDay(entireline, iline)
    wrapup()
end

# Fail if i is 0, else succeed.
procedure testFail(i)
    if i=0 then {
        # I don't need to fail explicitly; simply not executing "return"
        # seems to cause failure.
        #fail
    } else {
        return
    }
end

procedure test1()
    write("Welcome to test1")
    rem := "124.8T] 8.3 b."
    write("testing with: ",rem)
    inbrack := ""
    if rem ? {tab(match("[")) & inbrack := tab(many('0123456789T./')) ;  clbr := match("]") } then {
        write("Matched. inbrack=",inbrack," clbr=",clbr)
        rem2 := rem[clbr:0]
        write("rem2='",rem2,"'")
    }

    rem := "[123.8T] 8.4 b."
    write("testing with: ",rem)
    inbrack := ""
    if rem ? {tab(match("[")) & inbrack := tab(many('0123456789T./')) ;  clbr := match("]") } then {
        write("Matched. inbrack=",inbrack," clbr=",clbr)
        rem2 := rem[clbr:0]
        write("rem2='",rem2,"'")
    }

    rem := "25.18 miles b. (M400); 1.8 miles w. [130 mw.]"
    write("testing with: ",rem)
    inbrack := ""
    if rem ? {tab(find("[")) & move(1) & inbrack := tab(many(&ascii -- ']')) & clbr := match("]") } then {
        rem := replace(rem,"[" || inbrack || "]", "")
        write("Matched []. inbrack='",inbrack,"' clbr=",clbr," rem='", rem, "'")
    }

    if testFail(1) then {
        write("testFail(1) succeeded, as expected")
    } else {
        write("testFail(1) failed - Error!")
    }
    if testFail(0) then {
        write("testFail(0) succeeded - Error!")
    } else {
        write("testFail(0) failed, as expected")
    }    
end

procedure main(args)
    test := &null
    i := 1
    while i <= *args do {
        if args[i] == "-t" then {
            test := 1
        }
        i:=i+1
    }
    
    if \test then {
        test1()
    } else {
        readlines()
    }
end
